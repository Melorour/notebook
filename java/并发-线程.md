## 问：用Executors.newCachedThreadPool创建的线程池，在运行的过程中有可能产生的风险是？

答：newCachedThreadPool最大的风险就是可能会创建超多的线程，导致最后不能创建线程。

##问：实现一个自定义的ThreadFactory的作用通常是？

答：通常的作用是给线程取名字，便于以后查问题，很多查过问题的同学应该都会发现，看到jstack出来后一堆看不出名字意义的线程是多么的崩溃。

## 问：CountDownLatch、CyclicBarrier和Semaphore的用法？

答：
CountDownLatch
```
//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行
public void await() throws InterruptedException { };   
//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行
public boolean await(long timeout, TimeUnit unit) throws InterruptedException { };  
 //将count值减1
public void countDown() { }; 
```

CyclicBarrier:实现让一组线程等待至某个状态之后再全部同时执行.
```
CyclicBarrier barrier  = new CyclicBarrier(N); // N是等待的线程数量
cyclicBarrier.await();
```
Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可
```
Semaphore semaphore = new Semaphore(5); //5个可用信号
semaphore.acquire(); //占用1个
semaphore.release(); //释放1个
```
总结：
1. CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；
2. 而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。
3. Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。


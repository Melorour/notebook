## 为什么ConcurrentHashMap可以在高并发的情况下比HashMap更为高效？

主要是ConcurrentHashMap在实现时采用的拆分锁（事务分离，避免锁住大量数据），使用final、volatile。
```
 static final class HashEntry<K,V> {  
     final K key;  
     final int hash;  
     volatile V value;  
     final HashEntry<K,V> next;  
 } 
```
除了value不是final的，其它值都是final的，这意味着不能从hash链的中间或尾部添加或删除节点，因为这需要修改next 引用值，所有的节点的修改只能从头部开始。为了确保读操作能够看到最新的值，将value设置成volatile，这避免了加锁。

在 Java 8 和之后的版本中，ConcurrentHashMap 发生了哪些变化呢？
总体结构上，它的内部存储变得和我在专栏上一讲介绍的 HashMap 结构非常相似，同样是大的桶
（bucket）数组，然后内部也是一个个所谓的链表结构（bin），同步的粒度要更细致一些。
 - 其内部仍然有 Segment 定义，但仅仅是为了保证序列化时的兼容性而已，不再有任何结构上的用处。
 - 因为不再使用 Segment，初始化操作大大简化，修改为 lazy-load 形式，这样可以有效避免初始开销，解决了很多人抱怨的一点。
 - 数据存储利用 volatile 来保证可见性。
 - 使用 CAS 等操作，在特定场景进行无锁并发操作。
 - 使用 Unsafe、LongAdder 之类底层手段，进行极端情况的优化。

 ## 简述一下 CAS 算法 

 CAS算法的过程是这样：它包含三个参数 CAS（V,E,N）。V表示要更新的变量，E表示预期的值，N表示新值。仅当V值等于E值时，才会将V的值设置成N，否则什么都不做。最后CAS返回当前V的值。CAS算法需要你额外给出一个期望值，也就是你认为现在变量应该是什么样子，如果变量不是你想象的那样，那说明已经被别人修改过。你就重新读取，再次尝试修改即可。JDK并发包有一个atomic包，里面实现了一些直接使用CAS操作的线程安全的类型。其中最常用的一个类应该就是AtomicInteger。我们以此为例来研究一下没有锁的情况下如何做到线程安全。

## 用Executors.newCachedThreadPool创建的线程池，在运行的过程中有可能产生的风险是？

newCachedThreadPool最大的风险就是可能会创建超多的线程，导致最后不能创建线程。

## 实现一个自定义的ThreadFactory的作用通常是？

通常的作用是给线程取名字，便于以后查问题，很多查过问题的同学应该都会发现，看到jstack出来后一堆看不出名字意义的线程是多么的崩溃。

## CountDownLatch、CyclicBarrier和Semaphore的用法？

CountDownLatch
```
//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行
public void await() throws InterruptedException { };   
//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行
public boolean await(long timeout, TimeUnit unit) throws InterruptedException { };  
 //将count值减1
public void countDown() { }; 
```

CyclicBarrier:实现让一组线程等待至某个状态之后再全部同时执行.
```
CyclicBarrier barrier  = new CyclicBarrier(N); // N是等待的线程数量
cyclicBarrier.await();
```
Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可
```
Semaphore semaphore = new Semaphore(5); //5个可用信号
semaphore.acquire(); //占用1个
semaphore.release(); //释放1个
```
总结：
1. CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；
2. 而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。
3. Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。

